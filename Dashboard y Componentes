### dashboard/page.tsx
"use client"

import { useEffect, useState } from "react"
import { useRouter } from "next/navigation"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Label } from "@/components/ui/label"
import { Progress } from "@/components/ui/progress"
import { GraphVisualizer } from "@/components/graph-visualizer"
import { GraphSimple } from "@/lib/graph-simple"
import { checkAuth, logout } from "@/lib/auth"

const RATE_PER_SECOND = 0.5

export default function Dashboard() {
  const router = useRouter()
  const [user, setUser] = useState<{ name: string; email: string } | null>(null)
  const [sourceNode, setSourceNode] = useState<number | null>(null)
  const [targetNode, setTargetNode] = useState<number | null>(null)
  const [path, setPath] = useState<number[]>([])
  const [distance, setDistance] = useState(0)
  const [isAnimating, setIsAnimating] = useState(false)
  const [progress, setProgress] = useState(0)
  const [showResult, setShowResult] = useState(false)
  const [graph] = useState(() => {
    const g = new GraphSimple(6)
    g.addEdge(0, 1, 10)
    g.addEdge(0, 2, 15)
    g.addEdge(1, 2, 5)
    g.addEdge(1, 3, 12)
    g.addEdge(2, 3, 8)
    g.addEdge(2, 4, 14)
    g.addEdge(3, 4, 7)
    g.addEdge(3, 5, 20)
    g.addEdge(4, 5, 9)
    return g
  })

  useEffect(() => {
    const checkUserAuth = async () => {
      try {
        const userData = await checkAuth()
        if (userData) {
          setUser(userData)
        } else {
          router.push("/login")
        }
      } catch (error) {
        router.push("/login")
      }
    }
    checkUserAuth()
  }, [router])

  const handleLogout = async () => {
    await logout()
    router.push("/login")
  }

  const calculateRoute = () => {
    if (sourceNode === null || targetNode === null) return

    const { distances, predecessors } = graph.dijkstraSimple(sourceNode)
    const shortestPath = []
    let current = targetNode

    while (current !== sourceNode) {
      shortestPath.unshift(current)
      current = predecessors[current]
    }
    shortestPath.unshift(sourceNode)

    setPath(shortestPath)
    setDistance(distances[targetNode])
    setIsAnimating(true)
    setProgress(0)
    setShowResult(false)

    const animationDuration = distances[targetNode] * 1000
    const startTime = Date.now()

    const updateProgress = () => {
      const elapsed = Date.now() - startTime
      const newProgress = Math.min(100, (elapsed / animationDuration) * 100)
      setProgress(newProgress)

      if (newProgress < 100) {
        requestAnimationFrame(updateProgress)
      } else {
        setIsAnimating(false)
        setShowResult(true)
      }
    }
    requestAnimationFrame(updateProgress)
  }

  const resetRoute = () => {
    setSourceNode(null)
    setTargetNode(null)
    setPath([])
    setDistance(0)
    setIsAnimating(false)
    setProgress(0)
    setShowResult(false)
  }

  if (!user) {
    return <div className="min-h-screen flex items-center justify-center bg-sky-100">Cargando...</div>
  }

  return (
    <div className="min-h-screen bg-sky-100 p-4">
      <div className="max-w-4xl mx-auto">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-2xl font-bold">MoviSimple</h1>
          <div className="flex items-center gap-4">
            <span>Hola, {user.name}</span>
            <Button variant="outline" size="sm" onClick={handleLogout}>
              Cerrar Sesi√≥n
            </Button>
          </div>
        </div>

        <Card className="mb-6">
          <CardHeader>
            <CardTitle>Solicitar Viaje</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="source">Origen</Label>
                  <Select
                    value={sourceNode?.toString() || ""}
                    onValueChange={(value) => setSourceNode(Number.parseInt(value))}
                    disabled={isAnimating}
                  >
                    <SelectTrigger id="source">
                      <SelectValue placeholder="Selecciona el origen" />
                    </SelectTrigger>
                    <SelectContent>
                      {Array.from({ length: 6 }, (_, i) => (
                        <SelectItem key={`source-${i}`} value={i.toString()}>
                          Nodo {i}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                <div className="space-y-2">
                  <Label htmlFor="target">Destino</Label>
                  <Select
                    value={targetNode?.toString() || ""}
                    onValueChange={(value) => setTargetNode(Number.parseInt(value))}
                    disabled={isAnimating}
                  >
                    <SelectTrigger id="target">
                      <SelectValue placeholder="Selecciona el destino" />
                    </SelectTrigger>
                    <SelectContent>
                      {Array.from({ length: 6 }, (_, i) => (
                        <SelectItem key={`target-${i}`} value={i.toString()}>
                          Nodo {i}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                <Button
                  onClick={calculateRoute}
                  disabled={sourceNode === null || targetNode === null || sourceNode === targetNode || isAnimating}
                  className="w-full"
                >
                  Calcular Ruta
                </Button>

                {isAnimating && (
                  <div className="space-y-2">
                    <Label>Progreso del viaje</Label>
                    <Progress value={progress} className="h-2" />
                  </div>
                )}

                {showResult && (
                  <div className="p-4 bg-white rounded-lg shadow space-y-2">
                    <p>
                      <strong>Tiempo total:</strong> {distance} segundos
                    </p>
                    <p>
                      <strong>Costo:</strong> ${(distance * RATE_PER_SECOND).toFixed(2)}
                    </p>
                    <Button onClick={resetRoute} variant="outline" className="w-full mt-2">
                      Nuevo Viaje
                    </Button>
                  </div>
                )}
              </div>

              <div className="bg-white p-4 rounded-lg shadow">
                <GraphVisualizer
                  graph={graph}
                  sourceNode={sourceNode}
                  targetNode={targetNode}
                  path={path}
                  progress={progress}
                />
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  )
}
"use client"

import { useRef, useEffect } from "react"
import type { GraphSimple } from "@/lib/graph-simple"

interface GraphVisualizerProps {
  graph: GraphSimple
  sourceNode: number | null
  targetNode: number | null
  path: number[]
  progress: number
}

export function GraphVisualizer({ graph, sourceNode, targetNode, path, progress }: GraphVisualizerProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)

  const nodePositions = [
    { x: 100, y: 100 },
    { x: 250, y: 50 },
    { x: 250, y: 150 },
    { x: 400, y: 100 },
    { x: 400, y: 200 },
    { x: 550, y: 150 },
  ]

  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext("2d")
    if (!ctx) return

    ctx.clearRect(0, 0, canvas.width, canvas.height)

    // Draw edges
    for (let i = 0; i < graph.V; i++) {
      for (const { node: j, weight } of graph.adj[i]) {
        if (i < j) {
          const startPos = nodePositions[i]
          const endPos = nodePositions[j]

          const isPathEdge =
            path.length > 1 &&
            path.some((node, index) => {
              return (
                index < path.length - 1 &&
                ((path[index] === i && path[index + 1] === j) || (path[index] === j && path[index + 1] === i))
              )
            })

          ctx.beginPath()
          ctx.moveTo(startPos.x, startPos.y)
          ctx.lineTo(endPos.x, endPos.y)

          if (isPathEdge) {
            ctx.strokeStyle = "#3b82f6"
            ctx.lineWidth = 3
          } else {
            ctx.strokeStyle = "#9ca3af"
            ctx.lineWidth = 1
          }

          ctx.stroke()

          const midX = (startPos.x + endPos.x) / 2
          const midY = (startPos.y + endPos.y) / 2

          ctx.fillStyle = "#1f2937"
          ctx.font = "12px Arial"
          ctx.fillText(`${weight}s`, midX, midY - 5)
        }
      }
    }

    // Draw nodes
    for (let i = 0; i < graph.V; i++) {
      const pos = nodePositions[i]

      ctx.beginPath()
      ctx.arc(pos.x, pos.y, 20, 0, 2 * Math.PI)

      if (i === sourceNode) {
        ctx.fillStyle = "#22c55e"
      } else if (i === targetNode) {
        ctx.fillStyle = "#ef4444"
      } else if (path.includes(i)) {
        ctx.fillStyle = "#3b82f6"
      } else {
        ctx.fillStyle = "#f3f4f6"
      }

      ctx.fill()
      ctx.strokeStyle = "#1f2937"
      ctx.lineWidth = 1
      ctx.stroke()

      ctx.fillStyle = "#1f2937"
      ctx.font = "14px Arial"
      ctx.textAlign = "center"
      ctx.textBaseline = "middle"
      ctx.fillText(i.toString(), pos.x, pos.y)
    }

    // Draw progress animation
    if (path.length > 1 && progress > 0 && progress < 100) {
      const totalSegments = path.length - 1
      const progressPerSegment = 100 / totalSegments
      const currentSegmentIndex = Math.min(totalSegments - 1, Math.floor(progress / progressPerSegment))
      const segmentProgress = (progress % progressPerSegment) / progressPerSegment

      const startNode = path[currentSegmentIndex]
      const endNode = path[currentSegmentIndex + 1]

      const startPos = nodePositions[startNode]
      const endPos = nodePositions[endNode]

      const currentX = startPos.x + (endPos.x - startPos.x) * segmentProgress
      const currentY = startPos.y + (endPos.y - startPos.y) * segmentProgress

      ctx.beginPath()
      ctx.arc(currentX, currentY, 8, 0, 2 * Math.PI)
      ctx.fillStyle = "#f59e0b"
      ctx.fill()
      ctx.strokeStyle = "#1f2937"
      ctx.lineWidth = 1
      ctx.stroke()
    }
  }, [graph, sourceNode, targetNode, path, progress])

  return <canvas ref={canvasRef} width={650} height={300} className="w-full h-auto border border-gray-300 rounded-lg" />
}
       
